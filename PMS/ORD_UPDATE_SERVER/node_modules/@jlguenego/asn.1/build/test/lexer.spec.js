"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
// import util from 'util';
const fs_1 = require("fs");
const path_1 = require("path");
const ASN1Lexer_1 = require("../src/analysis/ASN1Lexer");
const ASN1CstParser_1 = require("../src/analysis/ASN1CstParser");
const ASN1Visitor_1 = require("../src/analysis/ASN1Visitor");
describe('Lexer Unit Test', () => {
    it('should tokenize', () => {
        const input = fs_1.readFileSync(path_1.resolve(__dirname, 'data/foo-protocol.asn1'), {
            encoding: 'utf8',
        });
        // lexical analysis.
        const output = ASN1Lexer_1.ASN1Lexer.tokenize(input);
        // syntaxic analysis. (parser)
        const parserInstance = new ASN1CstParser_1.ASN1CstParser();
        parserInstance.input = output.tokens;
        const cstOutput = parserInstance.ModuleDefinition();
        if (parserInstance.errors.length > 0) {
            console.error(parserInstance.errors);
            throw Error('Syntax error:\n' + parserInstance.errors[0].message);
        }
        const toAstVisitorInstance = new ASN1Visitor_1.ASN1Visitor();
        const module = toAstVisitorInstance.visit(cstOutput);
        assert_1.default.strictEqual(module.name, 'FooProtocol');
    });
});
//# sourceMappingURL=lexer.spec.js.map