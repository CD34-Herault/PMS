"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASN1Module = void 0;
const ASN1Lexer_1 = require("../analysis/ASN1Lexer");
const ASN1CstParser_1 = require("../analysis/ASN1CstParser");
const ASN1Visitor_1 = require("../analysis/ASN1Visitor");
const ASN1Validator_1 = require("../ASN1Validator");
const EncodingRule_1 = require("../EncodingRule");
const DEREncoder_1 = require("../codec/der/encoder/DEREncoder");
const ASN1Generator_1 = require("../ASN1Generator");
class ASN1Module {
    constructor(name) {
        this.name = name;
        this.assignments = [];
        this.assignments = [];
    }
    static compile(definition) {
        const output = ASN1Lexer_1.ASN1Lexer.tokenize(definition);
        const parserInstance = new ASN1CstParser_1.ASN1CstParser();
        parserInstance.input = output.tokens;
        const cstOutput = parserInstance.ModuleDefinition();
        if (parserInstance.errors.length > 0) {
            throw Error('Syntax error:\n' + parserInstance.errors[0].message);
        }
        const toAstVisitorInstance = new ASN1Visitor_1.ASN1Visitor();
        const ast = toAstVisitorInstance.visit(cstOutput);
        return ast;
    }
    addAssignment(type) {
        this.assignments.push(type);
    }
    getAssignment(name) {
        const assignment = this.assignments.find(a => a.name === name);
        if (!assignment) {
            throw new Error(`Assignment (type) not found: ${name}`);
        }
        return assignment;
    }
    validate(message, type) {
        const msg = JSON.parse(JSON.stringify(message));
        const validator = new ASN1Validator_1.ASN1Validator(this);
        validator.validate(msg, type);
        return msg;
    }
    generate(type, data, opts = {}) {
        const options = {
            encodingRule: EncodingRule_1.EncodingRule.DER,
            inputFormat: 'json',
            ...opts,
        };
        const generator = new ASN1Generator_1.ASN1Generator(this, type);
        const asn1Message = generator.generateFromJson(data);
        if (options.encodingRule === EncodingRule_1.EncodingRule.DER) {
            return Buffer.from(DEREncoder_1.DEREncode(asn1Message), 'hex');
        }
        throw new Error('generate: encoding rule not yet implemented: ' + options.encodingRule);
    }
}
exports.ASN1Module = ASN1Module;
//# sourceMappingURL=ASN1Module.js.map